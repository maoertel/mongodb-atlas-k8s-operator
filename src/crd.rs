use std::sync::Arc;

use kube::CustomResource;
use kuberator::ObserveGeneration;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

/// An `AtlasUser` struct is generated by the `CustomResource` derive macro.
/// This struct represents the spec part of the custom resource definition (CRD) for the `AtlasUser` resource.
#[derive(CustomResource, Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[kube(
    group = "moertel.com",
    version = "v1",
    kind = "AtlasUser",
    plural = "atlasusers",
    derive = "PartialEq",
    status = "AtlasUserStatus",
    namespaced
)]
#[serde(rename_all = "camelCase")]
pub struct AtlasUserSpec {
    /// The MongoDB Atlas organization ID
    pub org_id: String,
    /// The email address of the user to invite/manage
    pub username: String,
    /// The roles to assign to the user
    pub roles: AtlasUserRoles,
    /// The team IDs to assign the user to
    #[serde(default)]
    pub team_ids: Vec<String>,
}

/// Role assignments for an Atlas user
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema, Default)]
#[serde(rename_all = "camelCase")]
pub struct AtlasUserRoles {
    /// Group (project) role assignments
    #[serde(default)]
    pub group_role_assignments: Vec<GroupRoleAssignment>,
    /// Organization-level roles
    #[serde(default)]
    pub org_roles: Vec<OrgRoleName>,
}

/// A group (project) role assignment
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[serde(rename_all = "camelCase")]
pub struct GroupRoleAssignment {
    /// The group (project) ID
    pub group_id: String,
    /// The roles to assign within this group
    pub group_roles: Vec<GroupRoleName>,
}

/// Organization-level role names
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum OrgRoleName {
    OrgOwner,
    OrgMember,
    OrgGroupCreator,
    OrgBillingAdmin,
    OrgBillingReadOnly,
    OrgReadOnly,
}

/// Group (project) level role names
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum GroupRoleName {
    GroupClusterManager,
    GroupDataAccessAdmin,
    GroupDataAccessReadOnly,
    GroupDataAccessReadWrite,
    GroupOwner,
    GroupReadOnly,
    GroupSearchIndexEditor,
    GroupStreamProcessingOwner,
}

/// Status of the AtlasUser resource
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema, Default)]
#[serde(rename_all = "camelCase")]
pub struct AtlasUserStatus {
    /// The Atlas user ID (set after invitation/creation)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub user_id: Option<Arc<str>>,
    /// The membership status in the organization
    #[serde(skip_serializing_if = "Option::is_none")]
    pub membership_status: Option<UserOrgMembershipStatus>,
    /// The observed generation of the resource
    #[serde(skip_serializing_if = "Option::is_none")]
    pub observed_generation: Option<i64>,
    /// Error message if reconciliation failed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}

impl ObserveGeneration for AtlasUserStatus {
    fn add(&mut self, observed_generation: i64) {
        self.observed_generation = Some(observed_generation);
    }
}

/// The membership status of a user in an Atlas organization
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum UserOrgMembershipStatus {
    Active,
    Pending,
    Deleted,
}
